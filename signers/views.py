"""Contains all the views of Signer App."""import jsonfrom typing import Any, ClassVarfrom cryptography import x509from cryptography.hazmat.primitives import hashes, serializationfrom cryptography.hazmat.primitives.asymmetric import ec, padding, rsafrom django.contrib import messagesfrom django.http import HttpRequest, HttpResponse, JsonResponsefrom django.shortcuts import redirectfrom django.urls import reverse_lazyfrom django.utils import timezonefrom django.utils.decorators import method_decoratorfrom django.views import Viewfrom django.views.decorators.csrf import csrf_exemptfrom django.views.generic import CreateView, DeleteView, DetailView, ListView, UpdateViewfrom .forms import SignerFormfrom .models import SignedMessage, Signerfrom .utils.keygen import generate_private_key, load_private_key_objectclass SignerList(ListView):    """Class View for List of Signers."""    model = Signer    paginate_by = 10    template_name = 'signerlist.html'    context_object_name = 'signers'    ordering: ClassVar[list[str]] = ['-created_on']class SignerDelete(DeleteView):    """Class View for Deleting a Signer."""    model = Signer    paginate_by = 10    success_url = reverse_lazy('signerList')class SignerEdit(UpdateView):    """Class View for Updating/Editing the Signer."""    model = Signer    success_url = reverse_lazy('signerList')    form_class = SignerForm    template_name = 'addSigner.html'    context_object_name = 'signer'    def get_context_data(self, **kwargs: Any) -> dict[str, Any]:        """Adds the title to the context.        Args:            **kwargs: All keyword arguments are passed to super().get_context_data.        Returns:            The context for the page.        """        context = super().get_context_data(**kwargs)        context['form_title'] = 'Edit Signer'        return context    def form_valid(self, form: SignerForm) -> HttpResponse:        """Creates the keypair and certificate, and stores it in the db.        Args:            form: The SignerForm to create new signer.        Returns:            The HttpResponse corresponding to the success url.        """        signer = form.save(commit=False)        signer.private_key = generate_private_key(            algorithm_oid_str=signer.signing_algorithm,            curve_name=signer.curve,            key_size=signer.key_length,        )        private_key_obj = load_private_key_object(signer.private_key)        public_key = private_key_obj.public_key()        # Create self-signed certificate        builder = (            x509.CertificateBuilder()            .subject_name(                x509.Name(                    [                        x509.NameAttribute(x509.NameOID.COMMON_NAME, signer.unique_name),                    ]                )            )            .issuer_name(                x509.Name(                    [                        x509.NameAttribute(x509.NameOID.COMMON_NAME, signer.unique_name),                    ]                )            )            .public_key(public_key)            .serial_number(x509.random_serial_number())            .not_valid_before(timezone.now())            .not_valid_after(signer.expires_by)        )        certificate = builder.sign(private_key=private_key_obj, algorithm=hashes.SHA256())        signer.certificate = certificate.public_bytes(serialization.Encoding.PEM).decode()        signer.save()        return redirect(self.success_url)class SignerDetail(DetailView):    """View Class for Signer Details."""    model = Signer    paginate_by = 10    template_name = 'signer_detail.html'    def get_context_data(self, **kwargs: Any) -> dict[str, Any]:        """Adds signed messages object and certificate object to the context.        Args:            **kwargs: All keyword arguments are passed to super().get_context_data.        Returns: Gives the context data containing the signed messages object and certificate object fields.        """        context = super().get_context_data(**kwargs)        context['signed_messages'] = self.object.signed_messages.all()        try:            cert_obj = x509.load_pem_x509_certificate(self.object.certificate.encode())            context['cert_details'] = {                'subject': cert_obj.subject.rfc4514_string(),                'issuer': cert_obj.issuer.rfc4514_string(),                'serial_number': cert_obj.serial_number,                'not_valid_before': cert_obj.not_valid_before,                'not_valid_after': cert_obj.not_valid_after,                'certificate': cert_obj.public_bytes(encoding=serialization.Encoding.PEM).decode('utf-8'),            }        except ValueError:            messages.add_message(self.request, messages.ERROR, 'Failed to parse certificate.')        return contextclass SignerCreate(CreateView):    """For Signer Create View."""    model = Signer    form_class = SignerForm    template_name = 'addSigner.html'    success_url = reverse_lazy('signerList')    def get_context_data(self, **kwargs: Any) -> dict[str, Any]:        """Adds the title to the context.        Args:            **kwargs: All keyword arguments are passed to super().get_context_data.        Returns:            The context for the page.        """        context = super().get_context_data(**kwargs)        context['form_title'] = 'Add Signer'        return context    def form_valid(self, form: SignerForm) -> HttpResponse:        """Creates the keypair and certificate, and stores it in the db.        Args:            form: The SignerForm to create new signer.        Returns:            The HttpResponse corresponding to the success url.        """        signer = form.save(commit=False)        signer.private_key = generate_private_key(            algorithm_oid_str=signer.signing_algorithm,            curve_name=signer.curve,            key_size=signer.key_length,        )        private_key_obj = load_private_key_object(signer.private_key)        public_key = private_key_obj.public_key()        # Create self-signed certificate        builder = (            x509.CertificateBuilder()            .subject_name(                x509.Name(                    [                        x509.NameAttribute(x509.NameOID.COMMON_NAME, signer.unique_name),                    ]                )            )            .issuer_name(                x509.Name(                    [                        x509.NameAttribute(x509.NameOID.COMMON_NAME, signer.unique_name),                    ]                )            )            .public_key(public_key)            .serial_number(x509.random_serial_number())            .not_valid_before(timezone.now())            .not_valid_after(signer.expires_by)        )        certificate = builder.sign(private_key=private_key_obj, algorithm=hashes.SHA256())        signer.certificate = certificate.public_bytes(serialization.Encoding.PEM).decode()        signer.save()        return super().form_valid(form)@method_decorator(csrf_exempt, name='dispatch')class SignHashAPIView(View):    """API view for sending POST request to get Signature."""    def post(self, request: HttpRequest) -> HttpResponse:        """Send POST request when API is called.        Args:            request:POST        Returns:HTTPResponse containing the signature object.        """        try:            data = json.loads(request.body)            signer_id = data.get('signer_id')            hash_hex = data.get('hash')            if not signer_id or not hash_hex:                return JsonResponse({'error': 'Missing signer_id or hash'}, status=400)            signer = Signer.objects.get(pk=signer_id)            private_key = load_private_key_object(signer.private_key)            hash_bytes = bytes.fromhex(hash_hex)            if isinstance(private_key, rsa.RSAPrivateKey):  # RSA                signature = private_key.sign(hash_bytes, padding.PKCS1v15(), getattr(hashes, signer.hash_function)())            elif isinstance(private_key, ec.EllipticCurvePrivateKey):  # ECC                signature = private_key.sign(hash_bytes, ec.ECDSA(getattr(hashes, signer.hash_function)()))            else:                return JsonResponse({'error': 'Unsupported algorithm'}, status=400)            SignedMessage.objects.create(signer=signer, hash_value=hash_hex, signature=signature.hex())            return JsonResponse({'signature': signature.hex()}, status=200)        except Signer.DoesNotExist:            return JsonResponse({'error': 'Signer not found'}, status=404)